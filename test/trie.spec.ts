const {describe, expect, test, beforeEach} = require("@jest/globals");
const {Trie, TrieNode} = require("../dist/grove.js");

describe("Trie and TrieNode Tests", () => {
    let trie;

    beforeEach(() => {
        trie = new Trie();
    });

    describe("TrieNode Tests", () => {

        test("should add and delete child nodes", () => {
            const parentNode = new TrieNode(null, true);
            const childNode = new TrieNode({ key: "A", node: parentNode });

            parentNode.addChild("A", childNode);
            expect(parentNode.hasChild("A")).toBe(true);
            expect(parentNode.children["A"]).toBe(childNode);

            parentNode.deleteChild("A");
            expect(parentNode.hasChild("A")).toBe(false);
        });

        test("should update a node's data and mark it as end of word", () => {
            const node = new TrieNode(null, true);

            node.update("Test Data");
            expect(node.isEndOfWord).toBe(true);
            expect(node.data).toBe("Test Data");

            node.update(null);
            expect(node.isEndOfWord).toBe(false);
            expect(node.data).toBe(null);
        });

        test("should unlink a node", () => {
            const node = new TrieNode(null, true);
            node.unlink();
            expect(node.parent).toEqual({ key: "", node: null });
        });
    });

    describe("Trie Tests", () => {
        test("should insert and search for a word", () => {
            const word = "HELLO";

            trie.insert(word);
            expect(trie.search(word)).toBe(1); // Data is autogenerated
        });

        test("should return null for a non-existent word", () => {
            expect(trie.search("WORLD")).toBeNull();
        });

        test("should delete a word", () => {
            const word = "DELETE";

            trie.insert(word);
            expect(trie.search(word)).toBe(1);

            trie.delete(word);
            expect(trie.search(word)).toBeNull();
        });

        test("should update data for a word", () => {
            const word = "UPDATE";
            const newData = "Updated Data";

            trie.insert(word, "Old Data");
            expect(trie.search(word)).toBe("Old Data");

            trie.update(word, newData);
            expect(trie.search(word)).toBe(newData);
        });

        test("should handle words with common prefixes", () => {
            trie.insert("CAT");
            trie.insert("CATS");
            trie.insert("CAR");

            expect(trie.search("CAT")).toBe(1);
            expect(trie.search("CATS")).toBe(2);
            expect(trie.search("CAR")).toBe(3);
        });

        test("should handle deletion of word with shared prefixes", () => {
            trie.insert("DOG");
            trie.insert("DOGS");

            trie.delete("DOG");
            expect(trie.search("DOG")).toBeNull();
            expect(trie.search("DOGS")).toBe(2);
        });

        test("should retrieve path to a word", () => {
            trie.insert("PATH");

            const path = trie.getPath("PATH");
            expect(path.length).toBe(5); // Includes root node
            expect(path[0]).toBe(trie.root); // Root node
            expect(path[4]?.word).toBe("PATH");
        });

        test("should get data node for a word", () => {
            trie.insert("DATA", "Some data");

            const node = trie.getDataNode("DATA");
            expect(node).not.toBeNull();
            expect(node.data).toBe("Some data");
        });

        test("should handle case-insensitive words", () => {
            trie.insert("CASE");
            expect(trie.search("case")).toBeNull(); // Strict matching
        });
    });
});